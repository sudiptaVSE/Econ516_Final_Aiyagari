{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Iterate on aggregate assets"
     ]
    },
    {
     "ename": "LoadError",
     "evalue": "UndefVarError: currentassets not defined",
     "output_type": "error",
     "traceback": [
      "UndefVarError: currentassets not defined",
      "",
      "Stacktrace:",
      " [1] get_consEGM(::Array{Float64,1}, ::AggVarsEGM{Float64,Float64}, ::Array{Float64,1}, ::AiyagariModelEGM{Float64,Int64}, ::Array{Float64,1}) at C:\\Users\\gsudi\\Dropbox\\2nd yr  ubc\\econ 516\\Econ516_Final_Aiyagari\\Aiyagari94EGM.jl:136",
      " [2] EulerBackEGM at C:\\Users\\gsudi\\Dropbox\\2nd yr  ubc\\econ 516\\Econ516_Final_Aiyagari\\Aiyagari94EGM.jl:155 [inlined]",
      " [3] SolveEGM(::Array{Float64,1}, ::AggVarsEGM{Float64,Float64}, ::AiyagariModelEGM{Float64,Int64}, ::Array{Float64,1}, ::Array{Float64,1}, ::Float64) at C:\\Users\\gsudi\\Dropbox\\2nd yr  ubc\\econ 516\\Econ516_Final_Aiyagari\\Aiyagari94EGM.jl:195",
      " [4] SolveEGM(::Array{Float64,1}, ::AggVarsEGM{Float64,Float64}, ::AiyagariModelEGM{Float64,Int64}, ::Array{Float64,1}, ::Array{Float64,1}) at C:\\Users\\gsudi\\Dropbox\\2nd yr  ubc\\econ 516\\Econ516_Final_Aiyagari\\Aiyagari94EGM.jl:192",
      " [5] equilibriumEGM(::Array{Float64,1}, ::AiyagariModelEGM{Float64,Int64}, ::Float64, ::Float64, ::Int64) at C:\\Users\\gsudi\\Dropbox\\2nd yr  ubc\\econ 516\\Econ516_Final_Aiyagari\\Aiyagari94EGM.jl:264",
      " [6] equilibriumEGM(::Array{Float64,1}, ::AiyagariModelEGM{Float64,Int64}, ::Float64) at C:\\Users\\gsudi\\Dropbox\\2nd yr  ubc\\econ 516\\Econ516_Final_Aiyagari\\Aiyagari94EGM.jl:248",
      " [7] top-level scope at In[9]:334",
      " [8] include_string(::Function, ::Module, ::String, ::String) at .\\loading.jl:1091"
     ]
    }
   ],
   "source": [
    "using LinearAlgebra\n",
    "using Parameters\n",
    "using IterativeSolvers\n",
    "using FastGaussQuadrature\n",
    "using ForwardDiff\n",
    "using QuantEcon\n",
    "using Plots\n",
    "using Arpack\n",
    "using BenchmarkTools\n",
    "#include(\"utils.jl\")\n",
    "################################### Model types #########################\n",
    "\n",
    "uPrime(c,γ) = c.^(-γ)\n",
    "uPrimeInv(up,γ) = up.^(-1.0/γ)\n",
    "\n",
    "struct Params{T <: Real}\n",
    "    β::T\n",
    "    α::T\n",
    "    δ::T\n",
    "    γ::T\n",
    "    ρ::T\n",
    "    σz::T #st. deviation of Z shock\n",
    "    σ::T #bad state\n",
    "    lamw::T #good state prob\n",
    "    Lbar::T\n",
    "    amin::T\n",
    "    error::T\n",
    "end\n",
    "\n",
    "mutable struct Mit_shock{T <: Real,I <: Integer}\n",
    "    params::Params{T}\n",
    "    aGrid::Array{T,1} ##Policy grid\n",
    "    aGridl::Array{T,1}\n",
    "    na::I ##number of grid points in policy function\n",
    "    dGrid::Array{T,1}\n",
    "    nd::I ##number of grid points in distribution\n",
    "    states::Array{T,1}  \n",
    "    ns::I ##number of states\n",
    "    Trans_mat::Array{T,2}\n",
    "end\n",
    "mutable struct AggVars{T <: Real}\n",
    "    R::T\n",
    "    w::T\n",
    "end\n",
    "\n",
    "function Prices(K,Z,params::Params)\n",
    "    @unpack β,α,δ,γ,ρ,σ,lamw,Lbar = params\n",
    "    R = Z*α*(K/Lbar)^(α-1.0) + 1.0 - δ\n",
    "    w = Z*(1.0-α)*(K/Lbar)^(1.0-α) \n",
    "    \n",
    "    return AggVars(R,w)\n",
    "end\n",
    "\n",
    "function Model(\n",
    "    K::T,\n",
    "    β::T = 0.98,\n",
    "    α::T = 0.4,\n",
    "    δ::T = 0.02,\n",
    "    γ::T = 2.0,\n",
    "    ρ::T = 0.95,\n",
    "    σz::T = 1.0,\n",
    "    σ::T = 0.2,\n",
    "    lamw::T = 0.6,\n",
    "    Lbar::T = 1.0,\n",
    "    amin::T = 0.0,\n",
    "    amax::T = 200.0,\n",
    "    error::T = 1000000000.0,\n",
    "    na::I = 201,\n",
    "    nd::I = 201,\n",
    "    ns::I = 2,\n",
    "    endow = [1.0;2.5]) where{T <: Real,I <: Integer}\n",
    "\n",
    "    #############Params\n",
    "    params = Params(β,α,δ,γ,ρ,σz,σ,lamw,Lbar,amin,error)\n",
    "    AggVars = Prices(K,1.0,params)\n",
    "    @unpack R,w = AggVars\n",
    "\n",
    "    ################## Policy grid\n",
    "    function make_grid(a_min,a_max,na, s)\n",
    "        x = range(a_min,step=0.5,length=na)\n",
    "        grid = a_min .+ (a_max-a_min)*(x.^s/maximum(x.^s))\n",
    "        return grid\n",
    "    end\n",
    "    aGrid = make_grid(amin,amax,na,4.0)\n",
    "    dGrid=aGrid\n",
    "\n",
    "    ################## Transition\n",
    "    Trans_mat = [1.0-lamw σ ;lamw 1.0-σ]\n",
    "    dis = LinearAlgebra.eigen(Trans_mat)\n",
    "    m = argmin(abs.(dis.values .- 1.0)) \n",
    "    stdist = abs.(dis.vectors[:,m]) / sum(abs.(dis.vectors[:,m]))\n",
    "    lbar = dot(stdist,endow)\n",
    "    states = endow/lbar\n",
    "\n",
    "    @assert sum(Trans_mat[:,1]) == 1.0 ###sum to 1 across rows\n",
    "    guess = vcat(10.0 .+ aGrid,10.0 .+ aGrid)\n",
    "\n",
    "    \n",
    "    return Mit_shock(params,aGrid,vcat(aGrid,aGrid),na,dGrid,nd,states,ns,Trans_mat),guess,AggVars\n",
    "end\n",
    "\n",
    "function interp(x::AbstractArray,\n",
    "                y::AbstractArray,\n",
    "                x1::T,\n",
    "                na::Integer) where{T <: Real}\n",
    "    \n",
    "    np = searchsortedlast(x,x1)\n",
    "\n",
    "    ##Adjust indices if assets fall out of bounds\n",
    "    (np > 0 && np < na) ? np = np : \n",
    "        (np == na) ? np = na-1 : \n",
    "            np = 1        \n",
    "    #@show np\n",
    "    x_l,x_h = x[np],x[np+1]\n",
    "    y_l,y_h = y[np], y[np+1] \n",
    "    y1 = y_l + (y_h-y_l)/(x_h-x_l)*(x1-x_l) \n",
    "    \n",
    "    above =  y1 > 0.0 \n",
    "    return above*y1,np\n",
    "end\n",
    "\n",
    "\n",
    "function get_cons(policy::AbstractArray,\n",
    "               Pr::AggVars,\n",
    "               currentassets::AbstractArray,\n",
    "               Mit_shock::Mit_shock,\n",
    "               cpolicy::AbstractArray) \n",
    "\"\"\"\n",
    "This function gets the consumption implied by savings. With EGM, I start with some level of savings (current assets), then I get the implied asset holdings that I enter the period with (policy), \n",
    "this requires finding  corresponding index of currentassets  in policy, and projecting onto aGrid\n",
    "######Inputs\n",
    "policy: column vector of size ns*na - first na elements correspond to 1st idiosyncratic state, and so on \n",
    "Pr: type with Interest rate and wage associated with current aggregate states\n",
    "currentassets: 1 dimensional vector of size ns*na\n",
    "######Outputs\n",
    "cpolicy: consumption series - na*ns\n",
    "\"\"\"\n",
    "    \n",
    "    @unpack aGrid,na,ns,states = Mit_shock\n",
    "    \n",
    "    pol = reshape(policy,na,ns)\n",
    "    for si = 1:ns\n",
    "        for ai = 1:na\n",
    "            asi = (si - 1)*na + ai\n",
    "            cpolicy[asi] = Pr.R*currentassets[asi] + Pr.w*states[si] - interp(policy[:,si],aGrid,currentassets[asi],na)[1]\n",
    "        end\n",
    "    end\n",
    "    return cpolicy\n",
    "end\n",
    "\n",
    "function EulerBack(policy::AbstractArray,\n",
    "                   Pr::AggVars,\n",
    "                   Pr_P::AggVars,\n",
    "                   Mit_shock::Mit_shock,\n",
    "                   cpo::AbstractArray,\n",
    "                   apolicy::AbstractArray)\n",
    "\n",
    "\"\"\"\n",
    "This function updates the asset policy based on current policy  using the Euler equation in a savings problem  then get implied assets  and consumption \n",
    "from saving decisions based on the initial grid (aGridl) \n",
    "######Inputs\n",
    "policy: 1 dimensional vector of size ns*na - first na elements correspond to 1st idiosyncratic state, 2nd na to 2nd idiosyncratic state and so on \n",
    "Pr: Interest rate and wage associated with current aggregate states today\n",
    "Pr_p: Interest rate and wage associated with current aggregate states tomorrow\n",
    "Mit_shock: holds model type with various objects\n",
    "cpolicy: vector to be filled with consumption on the grid\n",
    "apolicy: vector to be filled with policy on the grid\n",
    "######Outputs\n",
    "apolicy: asset policy vector of size na*ns\n",
    "cpolicy: consumption vector of size na*ns\n",
    "\"\"\"\n",
    "\n",
    "    @unpack params,na,nd,ns,aGridl,Trans_mat,states = Mitshock\n",
    "    @unpack γ,β = params\n",
    "\n",
    "    R_P,w_P = Pr_P.R,Pr_P.w\n",
    "    R,w = Pr.R,Pr.w\n",
    "    \n",
    "    cons = get_cons(policy,Pr_P,aGridl,Mit_shock,cpolicy)\n",
    "    upcons = uPrime(cp,γ)\n",
    "    Eupcons = copy(cpolicy)\n",
    "    \n",
    "    for ai = 1:na\n",
    "        for si = 1:ns\n",
    "            asi = (si-1)*na + ai\n",
    "            Eupcons_sp = 0.0\n",
    "            for spi = 1:ns\n",
    "                aspi = (spi-1)*na + ai\n",
    "                Eupcons_sp += Trans_mat[spi,si]*upcons[aspi]\n",
    "            end\n",
    "            Eupcons[asi] = Eupcons_sp \n",
    "        end\n",
    "    end\n",
    "\n",
    "    upc = R_P*β*Eupcons\n",
    "\n",
    "    c = uPrimeInv(upc,γ)\n",
    "\n",
    "    for ai = 1:na\n",
    "        for si = 1:ns\n",
    "            asi = (si-1)*na+ai\n",
    "            apolicy[asi] = (aGridl[asi] + c[asi] - w*states[si])/R\n",
    "        end\n",
    "    end\n",
    "\n",
    "    return apolicy,c\n",
    "end\n",
    "\n",
    "function SolveIndProblem(policy::AbstractArray,\n",
    "                         Pr::AggVars,\n",
    "                         Mit_shock::Mit_shock,\n",
    "                         cpolicy::AbstractArray,\n",
    "                         apolicy::AbstractArray,tol = 1e-16)\n",
    "    @unpack ns,na = Mit_shock\n",
    "\n",
    "    for i = 1:10000\n",
    "        a = EulerBack(policy,Pr,Pr,Mit_shock,cpolicy,apolicy)[1]\n",
    "        if (i-1) % 50 == 0\n",
    "            heck = abs.(a - policy)/(abs.(a) + abs.(policy))\n",
    "            if maximum(check) < tol\n",
    "                println(\"converged in \",i,\" \",\"iterations\")\n",
    "                break\n",
    "            end\n",
    "        end\n",
    "        policy = copy(a)\n",
    "    end\n",
    "    return policy\n",
    "end\n",
    "\n",
    "function MakeTransMatEGM(policy,Mit_shock,tmat)\n",
    "    @unpack ns,na,aGrid,Trans_mat = Mit_shock\n",
    "    policy = reshape(policy,na,ns)\n",
    "    for a_i = 1:na\n",
    "        for j = 1:ns\n",
    "            x,i = interp(policy[:,j],aGrid,aGrid[a_i],na)\n",
    "            p = (aGrid[a_i] - policy[i,j])/(policy[i+1,j] - policy[i,j])\n",
    "            p = min(max(p,0.0),1.0)\n",
    "            sj = (j-1)*na\n",
    "            for k = 1:ns\n",
    "                sk = (k-1)*na\n",
    "                tmat[sk+i+1,sj+a_i] = p * Trans_mat[k,j]\n",
    "                tmat[sk+i,sj+a_i] = (1.0-p) * Trans_mat[k,j]\n",
    "            end\n",
    "        end\n",
    "    end\n",
    "    return tmat\n",
    "end\n",
    "\n",
    "function StationaryDistributionEGM(T)\n",
    "    N = size(T,1)\n",
    "    λ, x = powm!(T, rand(N), maxiter = 100000,tol = 1e-11)\n",
    "    return x/sum(x)\n",
    "end\n",
    "\n",
    "function UpdateAggs(\n",
    "    initialpolicy::AbstractArray,\n",
    "    initialdis::AbstractArray,\n",
    "    Kguess::AbstractArray,\n",
    "    Zpath::AbstractArray,\n",
    "    Mit_shock::Mit_shock,\n",
    "    tol = 1e-8,maxn = 50)\n",
    "\n",
    "    @unpack params,aGridl,na,nd,ns = Mit_shock\n",
    "\n",
    "    Periods = length(Kguess)\n",
    "    tmat = zeros(eltype(initialpolicy),(na*ns,na*ns))\n",
    "    cmat = zeros(eltype(initialpolicy),na*ns)\n",
    "    cmat2 = zeros(eltype(initialpolicy),na*ns)\n",
    "    apols = zeros(eltype(initialpolicy),na*ns,Periods)\n",
    "    devol = zeros(eltype(initialpolicy),na*ns,Periods)\n",
    "    aggK  = zeros(TimePeriods)\n",
    "\n",
    "    ##Find policies back through time\n",
    "    policy = initialpolicy\n",
    "    apols[:,Periods] = policy\n",
    "    for i = Periods:-1:2\n",
    "        #println(\"time: \",i-1)\n",
    "        K,Z_P = Kguess[i],Zpath[i]\n",
    "        K_m,Z = Kguess[i-1],Zpath[i-1]\n",
    "        Pr_P = Prices(K,Z_P,params)\n",
    "        Pr = Prices(K_m,Z,params)\n",
    "        #cmat .= 0.0\n",
    "        #cmat2 .= 0.0\n",
    "        cmat = zeros(eltype(initialpolicy),na*ns)\n",
    "        cmat2 = zeros(eltype(initialpolicy),na*ns)\n",
    "        policy = EulerBack(policy,Pr,Pr_P,Mit_shock,cmat,cmat2)[1]\n",
    "        apols[:,i-1] = policy\n",
    "    end\n",
    "\n",
    "    #@show apols\n",
    "    ###Find Evolution of distribution\n",
    "    dis = initialdis\n",
    "    aggK[1] = dot(aGridl,dis)\n",
    "    devol[:,1] = dis\n",
    "    for i = 1:Periods-1\n",
    "        #println(\"time: \",i)\n",
    "        policy = apols[:,i] ### I think this wrong\n",
    "        tmat .= 0.0\n",
    "        trans = MakeTransMatEGM(policy,Mit_shock,tmat)\n",
    "        dis = trans*dis\n",
    "        aggK[i+1] = dot(aGridl,dis)\n",
    "        devol[:,i+1] = dis\n",
    "    end\n",
    "        \n",
    "    return apols,devol,aggK\n",
    "end\n",
    "\n",
    "function equilibrium(Kguess,Zpath,initialpolicy,initialdis,Mit_shock,tol = 1e-8,maxn = 50)\n",
    "\n",
    "    pol_ss,dis_ss = initialpolicy,initialdis\n",
    "    aggK = copy(Kguess)\n",
    "    apols,devol,aggK = UpdateAggs(pol_ss,dis_ss,Kguess,Zpath,MitModel)\n",
    "    #Kguess\n",
    "    for i = 1:100\n",
    "        #@show Kguess\n",
    "        apols,devol,aggK = UpdateAggs(pol_ss,dis_ss,Kguess,Zpath,Mit_shock)\n",
    "        @show dif = maximum(abs.(aggK - Kguess))\n",
    "        if dif < 1e-6\n",
    "            return apols,devol,aggK\n",
    "        end\n",
    "        Kguess = 0.2*aggK + 0.8*Kguess\n",
    "    end\n",
    "    #return print(\"did not converge\")\n",
    "    return apols,devol,aggK\n",
    "end\n",
    "\n",
    "####################################################\n",
    "\n",
    "##############Solve aiyagari economy\n",
    "## store policies, stationary distribution, and aggregate capital\n",
    "include(\"Aiyagari94EGM.jl\")\n",
    "K0 = 47.0\n",
    "AA0,pol0,Aggs0 = AiyagariEGM(K0)\n",
    "pol_ss,_,dis_ss,K_ss,_ = equilibriumEGM(pol0,AA0,K0)\n",
    "\n",
    "MIT,pol0,Pr0 = Model(K0)\n",
    "#pol_ss = readdlm(\"pol_ss.csv\")\n",
    "#dis_ss = readdlm(\"dis_ss.csv\")\n",
    "#K_ss = dot(dis_ss,AA0.aGridl)\n",
    "Periods = 200\n",
    "OffeqPathTime = 1\n",
    "\n",
    "### steady state productivity\n",
    "z_ss = 1.0\n",
    "\n",
    "### Create capital path guess and path of shocks\n",
    "Kguess = K_ss*ones(Periods+1) #add time 0\n",
    "Zpath = vcat(1.01*ones(OffeqPathTime),z_ss*ones(Periods+1-OffeqPathTime))\n",
    "\n",
    "### Solve for transition path back to steady state\n",
    "#apols,dpols,aggKs = UpdateAggs(pol_ss,dis_ss,Kguess,Zpath,AA0)\n",
    "eq_apols,eq_dpols,eq_aggKs = equilibrium(Kguess,Zpath,pol_ss,dis_ss,MIT) \n",
    "\n",
    "\n",
    "p1 = plot(AA0.aGrid,eq_dpols[1:AA0.na,1])\n",
    "p1 = plot!(AA0.aGrid,eq_dpols[1:AA0.na,div(Periods,2)])\n",
    "p1 = plot!(AA0.aGrid,eq_dpols[1:AA0.na,Periods])\n",
    "p2 = plot(collect(0:1:Periods),eq_aggKs,label=\"Aggregate capital  from Mit shock\")\n",
    "p = plot(p1,p2, layout=(1,2),size=(1000,400))\n",
    "savefig(p,\"MITplots.pdf\")\n",
    "###\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[32m\u001b[1m   Building\u001b[22m\u001b[39m FFTW → `C:\\Users\\gsudi\\.julia\\packages\\FFTW\\kcXL6\\deps\\build.log`\n"
     ]
    }
   ],
   "source": [
    "import Pkg\n",
    "using Pkg\n",
    "Pkg.build(\"FFTW\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.5.3",
   "language": "julia",
   "name": "julia-1.5"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.5.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
