{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "using LinearAlgebra\n",
    "using Parameters\n",
    "using IterativeSolvers\n",
    "using FastGaussQuadrature\n",
    "using ForwardDiff\n",
    "using QuantEcon\n",
    "using Plots\n",
    "using Arpack\n",
    "\n",
    "function SolveQZ(Γ0,Γ1,Ψ,Π)\n",
    "    \n",
    "    div = 1.0 + 1e-10\n",
    "    eps = 1e-10\n",
    "    F = schur!(complex(Γ0),complex(Γ1))\n",
    "    Lambda, Omega = F.S, F.T\n",
    "    alpha, beta = F.alpha, F.beta\n",
    "    Q, Z = adjoint(conj(F.Q)), F.Z\n",
    "\n",
    "    n = size(Lambda, 1)\n",
    "    neta = size(Π, 2)\n",
    "\n",
    "    dLambda = abs.(diag(Lambda))\n",
    "    dOmega = abs.(diag(Omega))\n",
    "    dLambda = max.(dLambda,fill(1e-10,size(dLambda))) #to avoid dividing by 0;\n",
    "    movelast = Bool[(dLambda[i] <= 1e-10) || (dOmega[i] > div * dLambda[i]) for i in 1:n]\n",
    "    nunstable = sum(movelast)\n",
    "    nstable = n-nunstable\n",
    "    iStable = 1:nstable\n",
    "    iUnstable = (nstable + 1):n\n",
    "\n",
    "    #Reorder schur to have explosive eigenvalues at the end\n",
    "    movelastno = fill(false,size(movelast))\n",
    "    for i in eachindex(movelast)\n",
    "        movelastno[i] = !movelast[i]\n",
    "    end\n",
    "    FS = ordschur!(F, movelastno)\n",
    "    Lambda, Omega, Q, Z = FS.S, FS.T, FS.Q, FS.Z\n",
    "    #@show abs.(diag(Lambda))\n",
    "\n",
    "    gev = hcat(dLambda, dOmega)\n",
    "    q1 = Q[:,iStable]\n",
    "    q2 = Q[:,iUnstable]\n",
    "    q2xΠ = adjoint(q2) * Π\n",
    "    q2xΨ = adjoint(q2) * Ψ\n",
    "    q1xΠ = adjoint(q1) * Π\n",
    "    ndeta1 = min(n - nunstable, neta)\n",
    "    \n",
    "    rq2   = rank(q2xΠ)\n",
    "    rq2q2 = rank([q2xΨ q2xΠ])\n",
    "    iexist = rq2 == rq2q2\n",
    "    iunique = rank(Q * Π) == rank(q2xΠ)\n",
    "    eu = hcat(iexist,iunique)\n",
    "\n",
    "    #Solve q1xΠ = Phi*q2xΠ by svd decomposition\n",
    "    #Phi = U1*D1*V1' * V2*inv(D2)*U2\n",
    "    A2Π = svd(q2xΠ)\n",
    "    A2Ψ = svd(q2xΨ)\n",
    "    A1Π = svd(q1xΠ)\n",
    "    bigevΠ2 = findall(A2Π.S .> eps)\n",
    "    bigevΨ2 = findall(A2Ψ.S .> eps)\n",
    "    bigevΠ1 = findall(A1Π.S .> eps)  \n",
    "    ueta2, deta2, veta2 = A2Π.U[:,bigevΠ2],Matrix(Diagonal(A2Π.S[bigevΠ2])),A2Π.V[:,bigevΠ2]  \n",
    "    teta, seta, weta = A2Ψ.U[:,bigevΨ2],Matrix(Diagonal(A2Ψ.S[bigevΨ2])),A2Ψ.V[:,bigevΨ2]\n",
    "    ueta1, deta1, veta1 = A1Π.U[:,bigevΠ1],Matrix(Diagonal(A1Π.S[bigevΠ1])),A1Π.V[:,bigevΠ1]\n",
    "    Phi =  (ueta1 * deta1 * adjoint(veta1)) * (veta2 * (deta2 \\ adjoint(ueta2)))\n",
    "\n",
    "    #See page 12 of Sims rational expectations document\n",
    "    L11 = Lambda[iStable,iStable]\n",
    "    L12 = Lambda[iStable,iUnstable]\n",
    "    L22 = Lambda[iUnstable,iUnstable]\n",
    "\n",
    "    O11 = Omega[iStable,iStable]\n",
    "    O12 = Omega[iStable,iUnstable]\n",
    "    O22 = Omega[iUnstable,iUnstable]\n",
    "\n",
    "    Z1 = Z[:,iStable]\n",
    "    \n",
    "    #Solve for the effect on lagged variables\n",
    "    L11inv = LinearAlgebra.inv(L11)\n",
    "    aux1 = hcat(O11,O12 - Phi*O22) * adjoint(Z)\n",
    "    aux2 = Z1*LinearAlgebra.inv(L11)\n",
    "    G1 = real(aux2*aux1)\n",
    "\n",
    "    #Solve for the effect of exogenous variables (Impact)\n",
    "    aux3 = vcat(hcat(L11inv, -L11inv*(L12-Phi*L22)),hcat(fill(0.0,(nunstable,nstable)),Matrix(I,nunstable,nunstable)))\n",
    "    H = Z*aux3\n",
    "    Impact = real(H * vcat(adjoint(q1) - Phi*adjoint(q2),fill(0.0,(nunstable,size(Ψ,1)))) * Ψ)\n",
    "\n",
    "    #Solve for the constant \n",
    "    #tmat = hcat(Matrix(I,nstable,nstable), -Phi)\n",
    "    #G0 = vcat(tmat * Lambda, hcat(zeros(nunstable,nstable), Matrix(I,nunstable,nunstable)))\n",
    "    #G = vcat(tmat * Omega, fill(0.0,(nunstable, n)))\n",
    "    #G0I = inv(G0)\n",
    "    #G = G0I * G\n",
    "    #usix = (nstable + 1):n\n",
    "    #Ostab = Omega[nstable+1:n,nstable+1:n]\n",
    "    #Lstab = Lambda[nstable+1:n,nstable+1:n]\n",
    "    #C = G0I * vcat(tmat * adjoint(Q) * C, (Lstab - Ostab) \\ adjoint(q2) * C)\n",
    "\n",
    "    return eu,G1,Impact\n",
    "end\n",
    "\n",
    "function SolveSystem(A,B,C,E,maxit = 1000)\n",
    "    P0 = fill(0.0,size(A))\n",
    "    S0 = fill(0.0,size(C))\n",
    "    for i = 1:maxit\n",
    "        P = -(A*P0 + B) \\ C\n",
    "        S = -(C*S0 + B) \\ A\n",
    "        @show test = maximum(C + B*P + A*P*P)\n",
    "        if test<0.0000000001  \n",
    "            break\n",
    "        end\n",
    "        P0 = P\n",
    "        S0 = S\n",
    "    end\n",
    "    Q = -(A*P0 + B)\\E\n",
    "    XP = LinearAlgebra.eigen(P0)\n",
    "    XS = LinearAlgebra.eigen(S0)\n",
    "    #@show XP.values\n",
    "    if maximum(abs.(XP.values)) > 1.0\n",
    "        error(\"Non existence\")\n",
    "    end\n",
    "    if maximum(abs.(XS.values)) > 1.0\n",
    "        error(\"No stable equilibrium\")\n",
    "    end\n",
    "\n",
    "    return P0,Q\n",
    "end\n",
    "\n",
    "function TurnABCEtoSims(A,B,C,E)\n",
    "    HasLead = any((abs.(A) .> 1e-9),dims = 2)\n",
    "    HasLead = reshape(HasLead,size(A,1))\n",
    "    Ashift = copy(A)\n",
    "    Bshift = copy(B)\n",
    "    Cshift = copy(C)\n",
    "\n",
    "    Ashift[.!HasLead,:] = B[.!HasLead,:]\n",
    "    Bshift[.!HasLead,:] = C[.!HasLead,:]\n",
    "    Cshift[.!HasLead,:] .= 0.0\n",
    "\n",
    "    #IsLag = findall(any((abs.(Cshift) .> 1e-9),dims=1))\n",
    "    ##Not sure why I have to use this Linear Indices function, but not using gives me an error in the adjcost case\n",
    "    IsLag = any((abs.(Cshift) .> 1e-9),dims=1)\n",
    "    IsLag = LinearIndices(IsLag)[findall(IsLag)]\n",
    "    n = size(A,1)\n",
    "    naux = length(IsLag)\n",
    "    iaux = n+1:n+naux\n",
    "\n",
    "    G = fill(0.0,(n+naux,n+naux))\n",
    "    H = fill(0.0,(n+naux,n+naux))\n",
    "\n",
    "    G[1:n,1:n] = -Ashift\n",
    "    H[1:n,1:n] = Bshift\n",
    "    H[1:n,iaux] = Cshift[:,IsLag]\n",
    "\n",
    "    for (i,col) in enumerate(IsLag)\n",
    "        G[n+i,n+i] = 1.0\n",
    "        H[n+i,col] = 1.0\n",
    "    end\n",
    "\n",
    "    nEE = length(findall(HasLead))\n",
    "    EE = fill(0.0,(n+naux,nEE))\n",
    "    leadeqs = findall(HasLead)\n",
    "    for (i,lead) in enumerate(leadeqs)\n",
    "        EE[lead,i] = 1.0\n",
    "    end\n",
    "    nE = size(E,2)\n",
    "    E = vcat(E,fill(0.0,(naux,nE)))\n",
    "    \n",
    "    G,H,E,EE = convert(Array{Float64},G),convert(Array{Float64},H),convert(Array{Float64},E),convert(Array{Float64},EE)\n",
    "    return G,H,E,EE\n",
    "end"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.5.3",
   "language": "julia",
   "name": "julia-1.5"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.5.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
